/**             В этом уроке 1 реализуем свою кастомную имлиментацию(AuthProviderImpl)
 *
 *                                             Spring Security
 *                         Как Spring Security встраивается в Spring приложения?
 *
 *
 *                 C помощью фильтров
 *
 *  HTTP запрос-----> Фильтры Security------->Spring приложение
 *  Фильтр,объект перехватывающий все входящие HTTP запросы.
 *  .............................................................................................
 *                     AuthenticationProvider и объект Authentication
 *
 *                             Как устроена Аутентификация в Spring
 * Credentials -логин и пароль
 * Principal- тот объект,который получается на выходе после успешной аутентификации(чаще всего кладется сам пользователь)
 *
 *
 *Authentication           AuthenticationProvider  -------> Обращаемся к БД
 * Credentials   -------->    authenticate()       -------> Обращаемся к серверу,который проводит аутентификацию
 * Подаем на вход                                  -------> .....
 *
 *
 * Authentication
 * Principal        <----------
 * Получаем на входе
 * после успешной аутентификации
 *
 * В приложении может быть несколько AuthenticationProvider
 * .......................................................................................................
 *                                 После успешной аутентификации
 *
 * Authentication
 * Principal         --- данные об аутентифицированном пользователе
 *
 * Теперь каждый раз,когда пользователь будет делать запрос к нашему приложению,мы будем иметь доступ к его объекту
 * Authentication(с Principal внутри)
 *
 *                      Как это возможно? Ведь HTTP-stateless(независим друг от друга,не имеет состояния)
 * Объект помещается в сессию пользователя.За то, чтобы при каждом запросе этот объект подгружался из сессии отвечает
 * отдельный фильтр Spring Security
 * Пока сессия пользователя действительна-можем получать объект Authentication и не заставлять пользователя проходить
 * аутентификацию еще раз
 * .........................................................................................................
 *                                   Сессии и Куки(Cookies)
 * Cookie(пара ключ=значение) посылаются браузером при каждом запросе и если сессия с id находится,это означает,
 * что пользователь аутентифицирован.
 * Из сессии мы получаем данный об этом пользователе(объект Authentication).Эти данные кладутся в поток текущего
 * пользователя(ThreadLocal) и доступны только в этом потоке
 *..........................................................................................................
 * Создаем папку security и в ней класс PersonDetails(класс обертка над нашей сущностью)
 * Он должен реализовывать  спец.интерфейс UserDetails
 *
 * public class PersonDetails implements UserDetails {
 * } ......................................................................................................
 * SecurityConfig является главным классом где мы настраиваем наш Spring Security
 *
 *  /////////////////////////////////////////////////////////////////////////////////////////////////////////////
 *   ------->  |  Использует
 *   .......> ... Реализует
 *
 *
 *
 *                               UserDetails                                          ORM+DATABASE
 *                            getAuthorities()                                             |
 *                             getPassword()       < .   .   .  .                          |
 *                             getUsername()                    .                         Person
 *                          isAccountNotExpired()                   .                       |
 *                             ........                                    .                |
 *                                                                              .  Person PersonDetails
 *                                                                                         |
 *                                                                                         |
 *                               SecurityConfig    ---->    AuthProviderImp ---->  PersonDetailsService
 *                                                                .                         .
 *                                                                .                         .
 *                                                                .                         .
 *                                                          AuthProvider              UserDetailsService
 *                                                          authenticate()            loadUserByUsername()
 *                                                           supports()
 *
 *Есть класс SecurityConfig в котором содержится вся конфигурация Spring Security
 * В этот класс с помощью Спринга аннотации @Autowired нашу реализацию AuthProviderImpl(содержит в себе логику
 * аутентификации и этот класс реализует интерфейс AuthProvider( в этом интерфейсе описаны 2 метода и мы их реализовали
 * в этом классе AuthProviderImpl и внедрили его в SecurityConfig
 * В этом классе AuthProviderImpl мы используем сервис PersonDetailService(потому что обращаемся к БД и ищем
 * пользователя по его имени) поэтому в AuthProviderImpl внедрили наш сервис PersonDetailService
 * В этом сервисе есть всего один метод loadUserByUsername()
 * В наш сервис PersonDetailService внедрен JPA репозиторий и через него мы делаем запрос к БД,мы получаем человека
 * по имени(объект Person).Затем в сервисе мы объект Person оборачиваем в наш класс PersonDetails и этот класс
 * в свою очередь,реализует интерфейс UserDetails(в котором содержаться методы)
 *
 *
 *
 *                            Текущая логика в AuthenticationProviderImpl
 *                                           |
 *                                           |
 *                                    AuthProviderImpl
 *                                          .
 *                                          .
 *                                     AuthProvider
 *                                     authenticate()
 *                                     supports()
 *
 *1) Получили объект с данными о пользователе из БД по имени
 * 2) Сравнить имя пользователя
 * 3)Сравнить пароль
 * 4)Вернуть объект Authentication с Principal внутри(данные пользователя)
 * С помощью сервиса PersonDetailService вызываем метод loadByUsername() передаем имя пользователя-ищем его в БД с
 * помощью Hibernate-получаем этого пользователя-оборачиваем его в класс PersonDetails-и возвращаем в AuthProviderImpl
 * этот объект класса PersonDetails с найденным пользователем
 * Затем в этом AuthProviderImpl сравниваем пользователя с тем именем которое было передано в форме,если все ок
 * то идем дальше и сравниваем пароли ,который передан в форме и тот который в БД. Если все совпадает то возвращаем
 * объект Authentication с Principal внутри(данные пользователя).Principal это объект PersonDetails
 *
 * Но вообще последние 3 пункта за нас может сделать Spring Security
 *..................................................................................................
 *...................................................................................................
 *...................................................................................................
 *...................................................................................................
 *
 * ///////////////////////////////////////////////////Part2/////////////////////////////////////////////////////////
 *                                На этом уроке доверим это Spring Security
 *
 *                                     Польза интерфейсов
 *
 *
 *  PersonDetailService                                           Person PersonDetails
 *         .                                                              .
 *         .                                                              .
 *  UserDetailService                                                 UserDetails
 *  loadUserByUsername()                                            getAuthorities()                                             |
 *                                                                  getPassword()
 *                                                                  getUsername()
 *                                                                  isAccountNotExpired()
 *
 * В своих классах мы реализовали стандартные интерфейсы SpringSecurity-> теперь Spring Security будет знать как
 * использовать наши классы
 *
 * 1) Знает какой метод вызывать в сервисе(PersonDetailService),что бы получить пользователя по имени
 * 2) Знает какие методы вызвать в пользователе(PersonDetails) что бы получить имя пользователя и пароль и тд
 *
 *
 *
 *                       Когда нужно реализовывать свой AuthenticationProvider?
 *
 *    SecurityConfig------>UserDetailService          Простая аутентификация,которая проводится на самом сервере
 *                        loadUserByUsername()
 *                          Здесь можем только найти
 *                          пользователя из БД
 *
 *
 *                             ......./////    VS    /////........
 *
 *
 *
 *   SecurityConfig------>AuthProviderImpl                Любая кастомная аутентификация(например которая проводится
 *                              .                         на удаленном центральном сервере CAS).При этом пароль
 *                              .                         чаще всего даже не хранится на нашем сервере
 *                          AuthProvider
 *                        authenticate()
 *                          supports()
 * Здесь можем сами реализовать
 * аутентификацию(есть пароль,
 * сами возвращаем Principal)
 * ................................................................................................................
 *   @Override
 *     protected void configure(HttpSecurity http) throws Exception{
 *         // конфигурируем сам Spring Security(какая страница отвечает за вход,ошибки и тд)
 *         // конфигурируем авторизацию
 *          http.csrf().disable()// отключили защиту от межсайтовой подделки запросов
 *          .formLogin().authorizeRequests().antMatchers("/auth/login","/error").permitAll().пускаем всех
 *          .anyRequest().authenticated().and()    не пускаем всех
 *          по адресу "/auth/login" пускаем пользователя.
 *          .loginPage("auth/login").// конфигурируем логин
 *                 loginProcessingUrl("/process_login").--куда отправляем данные с формы
 *                  defaultSuccessUrl("/hello",true).-после успешной аутентификации куда хотим перенаправило что бы нас
 *                   failureUrl("/auth/login?error").;--куда перенаправит в случае провала аутентификации
 *                   с ключом error. он придет в параметр запроса и с помощью представления покажет ошибку
 *     }              and().logout().logoutUrl("/logout").logoutSuccessUrl("/auth/login");--разлогиниваемся
 *     и переходим на страницу аутентификации опять
 * Это правила и они читаются сверху вниз
 *
 *
 *  ////////////////////////////////////ШИФРОВАНИЕ///////////////////////////////////////////////////////////////
 *
 *  Без шифрования:
 *
 *  Если база данных утечет,все пароль окажутся в руках злоумышленников
 *
 *  Хранить пароль в исходном виде-неуважение к персональным данным пользователя
 *
 *  Мы сами,как владельцы сервиса,не должны знать пароль пользователя.
 *
 *  Надо хранить только зашифрованную версию пароля
 *
 *  .............................................................................................................
 *                             Односторонние функции(One-way function)
 *                                   Главный компонент шифрования
 *
 *  Просто вычисляется в одну сторону,но не просто вычисляется обратно.
 *
 *    Как пример работа миксера по смешиванию ингредиентов.
 *    Набор продуктов-смешивание-однородная масса по которой сложно понять что за продукты были использованы и
 *    получить обратно из жидкой массы опять целый набор продуктов-фактически нереально
 *    Простые в одну сторону,сложные в обратную.
 *
 *    Как смешивание разных красок.
 *
 *
 *   Пример из математики:
 *   Умножение.
 *   Умножить одно число а на другое число б это легко.
 *   161269807939604*1261094609123363=203376485406994729311689368252
 *   А вот узнать по результату умножения,какие были числа а и б уже сложно.
 *   Перебором.  нереально долго. вариантов пар а и б может быть много
 *   ..........................................................................................................
 * Метод hashcode() в java:
 *Посчитать быстро,а вот по значению hashcode() восстановить саму строку -невозможно на практике
 * ..............................................................
 * SHA-256
 *
 * Bcrypt
 *
 * Известные алгоритмы шифрования.Все переводят исходный пароль в какую-то строку
 * .................................................................................................
 *                                  Возможные коллизии
 *
 *                                  password
 *                                    |
 *               $234kUD$ikj7DSH77uSDh7DSH&&uD.i&&DGy$SDU&SokdS8jD*8
 *                                    |
 *                               Russian Doll
 *                                    |
 *               $234kUD$ikj7DSH77uSDh7DSH&&uD.i&&DGy$SDU&SokdS8jD*8
 *
 * Теоретически возможно,ено настолько редки,что можно этим пренебречь
 * ....................................................................................
 * Важное свойство
 * Функции для шифрования должны быть детерминированны
 * Т.е,для аргумента х они всегда должны возвращать значение у
 * h(x)=y
 * Функция которая каждый раз возвращает разное значение для одного аргумента-не подходит
 * ..............................................................................................
 *                               Как будет работать приложение
 *
 * При регистрации:
 * bcrypt("пароль") -> hash (сохраняем в БД)
 *
 * При аутентификации:
 * bcrypt("пароль") -> hash
 * (Сравниваем с сохраненным в БД-Хеши совпали,значит и изначальные пароли совпадают-не совпали,значит разные пароли)
 * .............................................................
 * @Bean
 *     public PasswordEncoder getPasswordEncoder(){
 *         return new BCryptPasswordEncoder();// добавили шифрование BCrypt
 *     }
 *     ................................................
 *     public class RegistrationService {
 *     @Transactional
 *     public void register(Person person){// сохранили человека. рега прошла успешно
 *
 *     person.setPassword(passwordEncoder.encode(person.getPassword()));// устанавливаем пароль челу с енкод
 *
 *     peopleRepository.save(person);
 *
 *     }
 *...........................................................
 * public class SecurityConfig
 * //настраиваем аутентификацию
 *     protected void configure(AuthenticationManagerBuilder auth) throws Exception {
 *         auth.userDetailsService(personDetailsService)//передаем наш сервис что бы спринг сам все сделал за нас
 *                 .passwordEncoder(getPasswordEncoder());// добавили шифрование при аутентификации
 *
 *...............................................................................................................
 * //////////////////////////////////////////////////////////////////////////////////////////////////////////////
 *                                  CSRF(Cross-Site request Forgery)
 *                                  Межсайтовая подделка запроса
 *
 *                                Сookies same-origin policy
 *
 *     Google                            Facebook                          Yandex
 *    g_id=145                          f_id=1453                        ya_id=17532
 *
 *                                        БРАУЗЕР
 *                    Прошли аутентификацию на 3 сервисах(храним кукис в браузере)
 *
 *   Через день зашли на фейсбук.Браузер отправляет на сервер фейсбука только те кукис,которые были установлены
 *   самим фейсбуком.Не все кукис.Фейсбук не должен знать чужие кукис.
 *
 *   Случайно переходи на сайт злоумышленников. Туда сливаются все наши кукис,если бы не было
 *   Cookies same-origin Policy
 *   Это хоть какая-то защита,но не идеальная и может быть обойдена злоумышленниками.
 *   ...............................................
 *                                     CSRF
 *                                      |
 *                                     BANK
 *                                      |
 *                                      | b_id=145678
 *                                   Браузер
 *                  Прошли аутентификацию=можем перевести деньги
 *   POST запрос на сервер банка.Перевод совершается,ведь куки есть на браузере(Spring Security видит аутентифицированного
 *   пользователя и дает ему доступ на адрес,куда отправляются данные с формы)
 *    НО
 *    Злоумышленник может создать свой сайт и каким-то образом завлечь туда жертву
 *    На нем будет скрытая форма которая копирует форму с банка. input hidden.
 *    и value с значениями. номер счета куда деньги отправляются и сумма перевода.
 *    можем нажать на кнопку и отправить форму на сервер банка и будет осуществлен перевод средств мошенникам.
 *    тк наши кукис хранятся в браузере еще(мы вчера заходили в банк через него)
 *
 *    Иногда можно даже не нажимать на кнопку для отправки поддельной формы в банк.
 *    JS скрипт автоматически отправляет форму.
 *    ...........................................................
 *                                    Защита от CSRF
 *
 *   Мы отдаем формы пользователю
 *   Мы можем встраивать в форму динамический контент(с помощью Таймлифа)
 *   Давайте встраивать в каждую форму специальный токен,который генерируется каждый раз на стороне сервера и
 *   который может быть использован лишь один раз
 *   Формы,которые приходят без этого токена,или с неправильным токеном,будут отвергнуты
 *
 *   Браузер<---------Форма(Токен=123567) Сервер
 *   Браузер---------> Форма(токен=123567) Сервер(принято. токен правильный)
 *
 *
 *   <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>
 *   добавили токен в логин форму. спринг секьюрити будет предоставлять нам токен
 *
 *   если CSRF работает,то разлогиниваемся с помощью POST запроса
 *<form th:action="@{/logout}" th:method="POST">
 *     <input type="submit" value="Logout"/>
 * </form>
 *
 *
 *
 * ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
 *                                        АВТОРИЗАЦИЯ
 *
 * Все пользователи прошедшие авторизацию-------> /hello
 *
 *
 * Администратор----------------------> /hello   /admin
 *
 * Уже настраивали авторизацию
 * http.authorizeRequests()
 *                  .antMatchers("/auth/login","/auth/registration", "/error").permitAll()
 *                 .anyRequest().authenticated().
 *                  and()
 *                 .formLogin().loginPage("/auth/login").
 *                 loginProcessingUrl("/process_login").
 *
 *  Проверка правил идет сверху вниз,первое совпавшее правило применяется
 *  Поэтому более специфичные правила должны стоять выше более общих
 * .......................................................................................
 *                                   Authority vs Role
 *                              Два способа ограничивать доступ
 *
 *  РОЛИ(начинаются на ROLE_)                           Действия(Authorities)
 *
 *  ROLE_GUEST                                          AUTHENTICATE,REGISTRATE
 *                                                               +
 *  ROLE_USER                                           WITHDRAW_MONEY,SEND_MONEY
 *                                                               +
 *  ROLE_ADMIN                                                BAN_USER
 *
 * Действия настраивают доступы точнее
 *
 *  В Spring Security Role=Authority
 *  Но некоторые люди разделяют это понятие
 *  Role-более общая единица определения доступа(контейнер нескольких Authority)
 *  Authority-более мелкая единица определения действия(конкретное действие)
 *
 *
 *  .........................................................................................
 *  Сделаем 3 роли
 *  не аутентифицированный пользователь,ROLE_USER,ROLE_ADMIN
 *  ROLE_USER-аутентифицированный пользователь(/hello,/showUserInfo)
 *  ROLE_ADMIN-все что выше+может заходить на страницу /admin
 *
 *  ...................................
 * добавим в Person строку с ролью private String role
 *
 * @Transactional
 *     public void register(Person person){// сохранили человека. рега прошла успешно
 *
 *     person.setPassword(passwordEncoder.encode(person.getPassword()));// устанавливаем пароль челу с енкод
 *
 *     person.setRole("ROLE_USER");// каждый новый пользователь теперь имеет роль юзер
 *
 *     peopleRepository.save(person);
 *
 *     }
 *
 *     update person set role='ROLE_ADMIN' where id=7;
 *     назначили вручную админа в бд
 *
 *
 *  @Override
 *     public Collection<? extends GrantedAuthority> getAuthorities() {
 * // человек получает свою роль
 *        return Collections.singletonList(new SimpleGrantedAuthority(person.getRole()));
 *
 *
 *Authority чаще используется где есть список действий ролей
 *
 * ////////////////////////////////////////////////////////////////////////////
 *                               Аннотация @PreAuthorize
 * @EnableWebSecurity
 * @EnableGlobalMethodSecurity(prePostEnabled = true)// теперь можем использовать спец аннотацию
 * public class SecurityConfig extends WebSecurityConfigurerAdapter {
 *
 *@Service
 * public class AdminService {
 * @PreAuthorize("hasRole('ROLE_ADMIN')")// ограничили доступ через аннотацию. только для админа
 *     public void doAdminStuff(){
 *         System.out.println("Only Admin here");
 *     }
 * }
 *
 *
 *
 * /////////////////////////////////////////////////////////////////////////////////////////////////////////////
 *                                  JWT Token
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
